#include <iostream>
#include <iomanip>
#include <cassert>
#include <cstring>

using namespace std;

// Pointer Subterfuge
// 
//

/*************************************
 * 1. There must be a pointer used in the code.
 * 2. Through some vulnerability, there must be a way for user input to 
 * overwrite the pointer. This typically happens through a stack buffer 
 * vulnerability.
 * 3. After the pointer is overwritten, the pointer must be dereferenced.
 ****************************************/
void pointerSubterfugeVulnerability(long buffer[])
{
   char * p1 = "Safe";
   char * p2 = "Rosebud"; // the top secret password

   cout << p1; // now displaying different data than our safe string
}

/**************************************
 * INTEGER WORKING
 * Call pointerSubterfugeVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void pointerSubterfugeWorking()
{
   long buffer[1] = {0};
   pointerSubterfugeVulnerability(buffer);
}

/**************************************
 * 1. Provide input, either a buffer size or a single value, that is directly or
 * indirectly used in the vulnerable expression.
 * 2. The input must exceed the valid bounds of the data-type, resulting in an
 * overflow or underflow condition
 *************************************/
void pointerSubterfugeExploit()
{
   long buffer[1] = {4197490};
   pointerSubterfugeVulnerability(buffer);
}

// Array Index, assigned to:
// Collin
//

/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
void arrayVulnerability(int input)
{
    string data[10] = { "apple", "banana", "cherry", "date", "eggplant", "fig", "grapefruit", "honeydew", "ilama", "jujube" };
    cout << data[input];
}

/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arrayWorking()
{
    cout << "***************** Array Working ************\n";
    int input = 0;
    cout << "Accessing data at index 0...";
    arrayVulnerability(input);
}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 * existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 * that is desirable to the attacker
 *************************************/
void arrayExploit()
{
    cout << "***************** Array Exploit ************\n";
    int input = 10;
    cout << "Accessing data at index 10...";
    arrayVulnerability(input);    
}

// Stack Smashing, assigned to:
// Camila
//

/*************************************
 * 1. There must be a buffer (such as an array) on the stack.
 * 2. The buffer must be reachable from an external input.
 * 3. The mechanism to fill the buffer from the external input must not
 * correctly check for the buffer size.
 * 4. A buffer overrun (extend beyond the intended limits of the array) must
 * extend to the return address on the stack.
 ****************************************/
void stackSmashingVulnerability(string input)
{

    //valid user and passwords
    //1. buffer (such as an array)on the stack
    char password[10];
    const char* passwords[2] = { "sEcUrE", "1830restored" };


    //prompt for username and password
    //2. The buffer must be reacheable from an external input
    cout << "What is your password? ";
    //buffer overun 
    strcpy(password, input.c_str());
    cout << endl;
    cout << password;
    cout << endl;

    // identify the user
   //3. not really checking for buffer size
    int id = -1;
    for (int i = 0; i < 2; i++)
        if (strcmp(password, passwords[i]) == 0)
            id = i;


    // make a decision and displays a message to the user
    switch (id)
    {
    case 0:
        cout << "Welcome, you have full access\n";
        break;
    case 1:
        cout << "Users have limited access to many things\n";
        break;

    default:
        cout << "You are not authorized to access anything on the system.\n";
    }

}


/**************************************
 * STACK WORKING
 * Call stackSmashingVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void stackSmashingWorking()
{
    cout << "******** Stack Smashing Working ************\n";
    
    string safepassword = "sEcUrE";
    cout << "Good input:" << safepassword << endl;
    stackSmashingVulnerability(safepassword);
    cout << endl;
}

/**************************************
 * 1. The attacker must provide more data into the outwardly facing buffer
 * than the buffer is designed to hold.
 * 2. The attacker must know where the return address pointer resides on the
 * stack. This should be just beyond the end of the buffer.
 * 3. The attacker must insert machine language instructions in the buffer.
 * This may occur before, after, or even around the return address pointer.
 * The machine language could be already compiled code in the program.
 * 4. The attacker must overwrite the return address. The old value, directing
 * the flow of the program after the function is returned, must be changed
 * from the calling function to the provided machine language in step 3.
 *************************************/
void stackSmashingExploit()
{
    cout << "******** Stack Smashing Exploit ************\n";
    
    string wrongPassword = "1830restoredddddddddddd";
    cout << "Bad Input: " << wrongPassword << endl;
    cout << "\tType Enter to continue this will continue the program and crash" << endl;
    int wait = 0;
    string junk;
    while (wait == 0) {
        cin >> junk;
        wait = 1;
    }
    stackSmashingVulnerability(wrongPassword);
    cout << endl;
    
}

// Integer Overflow, assigned to:
// Devan
//

/*************************************
 * 1. There must be a security check represented by an expression.
 * 2. The expression must have the potential for overflow.
 * 3. At least one of the numbers used to compute the sentinel must be
 * reachable through external input. This sentinel is a variable used to make
 * the security decision from the first requirement
 ****************************************/
void integerOverflowVulnerability(int input)
{

    int vulnerable = 2147483647;
    int x = input;
    vulnerable = x + vulnerable; 
    cout << "vulnerable =" << vulnerable << endl;


}

/**************************************
 * INTEGER WORKING
 * Call integerOverflowVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void integerOverflowWorking()
{
    int x = 0;

    integerOverflowVulnerability(x);
}

/**************************************
 * 1. Provide input, either a buffer size or a single value, that is directly or
 * indirectly used in the vulnerable expression.
 * 2. The input must exceed the valid bounds of the data-type, resulting in an
 * overflow or underflow condition
 *************************************/
void integerOverflowExploit()
{
    int x = 1;
    integerOverflowVulnerability(x);
}

// ANSI Unicode, assigned to:
// Devan
//

/*************************************
 * 1. There must be a buffer where the basetype is greater than one.
 * 2. Validation of the buffer must check the size of the buffer rather than the
 * number of elements in the buffer.
 ****************************************/
void ansiUnicodeVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * ANSI WORKING
 * Call ansiUnicodeWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiUnicodeWorking()
{
    cout << "********** ANSI Unicode Working ************\n";
    
    ansiUnicodeVulnerability(/* parameters with non-malicious data */);
}

/**************************************
 * 1. The attacker must provide more than half as much data into the
 * outwardly facing buffer as it is designed to hold.
 * 2. From here, a variety of injection attacks are possible. The most likely
 * candidates are stack smashing or heap smashing. In the above example,
 * the third parameter of the copyUnicodeText() function is the number
 * of elements in the string (256 elements), not the size of the string (512
 * bytes). The end result is a buffer overrun of 256 bytes.
 *************************************/
void ansiUnicodeExploit()
{
    cout << "********** ANSI Unicode Exploit ************\n";

    ansiUnicodeVulnerability(/* parameters with malicious data */);
}

// ARC Injection, assigned to:
// Shaun
//

/*************************************
 * 1. There must be a function pointer used in the code.
 * 2. Through some vulnerability, there must be a way for user input to
 * overwrite the function pointer. This typically happens through a stack
 * buffer vulnerability.
 * 3. After the memory is overwritten, the function pointer must be
 * dereferenced.
 ****************************************/
string pointerFunctionSafe()
{
    return "Safe! :-)";
}

void arcInjectionVulnerability(long buffer[4] /*This fulfills requiermetn 2.*/)
{
    string(*pointerFunction)() = pointerFunctionSafe;                      //This fulfills requierment 1.

    if (buffer[0] != '123') pointerFunction = (string(*) ())(buffer);  //This fulfills requierment 3.
           
    cout << pointerFunction() << endl;
    cout << "This Memory address: " << pointerFunction << endl;
    cout << "Safe Memory address: " << pointerFunctionSafe << endl;
        
}

/**************************************
 * ARC WORKING
 * Call arcInjectionVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arcInjectionWorking()
{
    cout << "********* ARC Injection Working ************\n";
    
    long input[4];

    input[0] = '123';
    cout << "For our working arcInjection function we have an input of: " << input[0] << endl;
    
        arcInjectionVulnerability(input);
    

}

/**************************************
 * 1. The attacker must exploit a vulnerability allowing unintended access to
 * the function pointer.
 * 2. The attacker must have the address to another function which is to be
 * used to replace the existing function pointer.
 *************************************/
void arcInjectionExploit()
{
    cout << "*** ARC Injection Spray Exploit ************\n";

    long input[4];

    input[0] = 0x7113A7;
    cout << "For our exploited arcInjection function we have an input of: 0x7113A7" << endl;
    cout << "\tType Enter to continue this will cause the program to crash" << endl;
    cout << "\tThis crash is due to arcInjectionVulnerability being able directly overwrite the function pointer" << endl;
    int wait = 0;
    string junk;
    while (wait == 0) {
        cin >> junk;
        wait = 1;
    }
        arcInjectionVulnerability(input);

}

// V-Table Spraying, assigned to:
// Steve
//

/*************************************
 * 1. The vulnerable class must be polymorphic.
 * 2. The class must have a buffer as a member variable.
 * 3. Through some vulnerability, there must be a way for user input to
 * overwrite parts of the V-Table.
 * 4. After a virtual function pointer is overwritten, the virtual function must
 * be called.
 ****************************************/
void vTableSprayingVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * V-TABLE WORKING
 * Call vTableSprayingVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void vTableSprayingWorking()
{
    cout << "********** vTable Spray Working ************\n";
    
    vTableSprayingVulnerability(/* parameters with non-malicious data */);
}

/**************************************
 * 1. Through some vulnerability, the V-Table pointer or a function pointer
 * within the V-Table must be overwritten.
 * 2. The attacker must have the address to another V-Table pointer or a
 * function pointer.
 *************************************/
void vTableSprayingExploit()
{
    cout << "********** vTable Spray Exploit ************\n";
    
    vTableSprayingVulnerability(/* parameters with malicious data */);
}

// Heap Spraying, assigned to:
// Ivanro
//

/*************************************
 * 1. There must be two adjacent heap buffers.
 * 2. The first buffer must be reachable through external input.
 * 3. The mechanism to fill the buffer from the external input must not
 * correctly check for the buffer size.
 * 4. The second buffer must be released before the first.
 * 5. The first buffer must be overrun (extend beyond the intended limits of
 * the array).
 ****************************************/
string displayCharArray(const char* p)
{
    string output;
    for (int i = 0; i < 5; i++)
        output += string(" ") + (p[i] >= ' ' && p[i] <= 'z' ? p[i] : '.');
    return output;
}

void heapSprayingVulnerability(string input)
{
    char* buffer1 = new char[4];
    char* buffer2 = new char[4];

    assert(buffer1 < buffer2);
    cout << "Insert into Buffer #1:" << input << endl;
    strcpy(buffer1, input.c_str());
    cout << "Buffer 1 Before Delete: " << displayCharArray((char*)buffer1) << endl;
    cout << "Buffer 2 Before Delete: " << displayCharArray((char*)buffer2) << endl;

    delete[]buffer2;
    delete[]buffer1;

    cout << "Buffer 1 After Delete: " << displayCharArray((char*)buffer1) << endl;
    cout << "Buffer 2 After Delete: " << displayCharArray((char*)buffer2) << endl;
}

/**************************************
 * HEAP WORKING
 * Call heapSprayingVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void heapSprayingWorking()
{
    cout << "************ Heap Spray Working ************\n";
    string safeInput = "safe";
    heapSprayingVulnerability(safeInput);
    cout << endl;
}

/**************************************
 * 1. The attacker must provide more data into the outwardly facing heap
 * buffer than the buffer is designed to hold.
 * 2. The attacker must know the layout of the Memory Control Block (MCB)
 * (essentially a linked list) residing just after the buffer.
 * 3. The attacker must provide a new MCB containing both the location of
 * the memory overwrite and the new data to be overwritten.
 *************************************/
void heapSprayingExploit()
{
    cout << "************ Heap Spray Exploit ************\n";
    string badInput = "exploitVulnerability";
    heapSprayingVulnerability(badInput);
}


int main() {

    char choice = '0';
    while (choice == '0') {
        cout << "What test would you like to run.\n";
        cout << "\tArray Index     : 1" << endl;
        cout << "\tARC Injection   : 2" << endl;
        cout << "\tVTable Spraying : 3" << endl;
        cout << "\tStack Smashing  : 4" << endl;
        cout << "\tHeap Spraying   : 5" << endl;
        cout << "\tInteger Overflow: 6" << endl;
        cout << "\tANSI-Unicode    : 7" << endl;
        cout << "\tClose Program   : 8" << endl;
        cin >> choice;
        if (choice < '1' || choice > '8' || isdigit(choice) == false) {
            cout << "Invalid" << endl;
            choice = '0';
        }
        if (choice == '1') {
            arrayWorking();
            arrayExploit();
            choice = '0';
        }
        if (choice == '2') {
            arcInjectionWorking();
            arcInjectionExploit();
            choice = '0';
        }
        if (choice == '3') {
            vTableSprayingWorking();
            vTableSprayingExploit();
            choice = '0';
        }
        if (choice == '4') {
            stackSmashingWorking();
            stackSmashingExploit();
            choice = '0';
        }
        if (choice == '5') {
            heapSprayingWorking();
            heapSprayingExploit();
            choice = '0';
        }
        if (choice == '6') {
            integerOverflowWorking();
            integerOverflowExploit();
            choice = '0';
        }
        if (choice == '7') {
            ansiUnicodeWorking();
            ansiUnicodeExploit();
            choice = '0';
        }
    }
    
    //heapSprayingWorking();
    //heapSprayingExploit();

    return 0;
}
