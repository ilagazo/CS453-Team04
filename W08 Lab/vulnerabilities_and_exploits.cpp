#include <iostream>
#include <iomanip>
#include <cassert>
#include <cstring>

using namespace std;

// Array Index, assigned to:
// Collin
//

/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
void arrayVulnerability(int input)
{
   string data[10] = {"apple", "banana", "cherry", "date", "eggplant", "fig", "grapefruit", "honeydew", "ilama", "jujube"};
   cout << data[input];
}

/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arrayWorking()
{
   int input = 0;
   cout << "Accessing data at index 0...";
   arrayVulnerability(input);
}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 * existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 * that is desirable to the attacker
 *************************************/
void arrayExploit()
{
   int input = 10;
   cout << "Accessing data at index 10...";
   arrayVulnerability(input);
}

// Stack Smashing, assigned to:
// Camila
//

/*************************************
 * 1. There must be a buffer (such as an array) on the stack.
 * 2. The buffer must be reachable from an external input.
 * 3. The mechanism to fill the buffer from the external input must not 
 * correctly check for the buffer size.
 * 4. A buffer overrun (extend beyond the intended limits of the array) must 
 * extend to the return address on the stack.
 ****************************************/
void stackSmashingVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * STACK WORKING 
 * Call stackSmashingVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void stackSmashingWorking()
{
   stackSmashingVulnerability(/* parameters with non-malicious data */);
}

/**************************************
 * 1. The attacker must provide more data into the outwardly facing buffer 
 * than the buffer is designed to hold.
 * 2. The attacker must know where the return address pointer resides on the 
 * stack. This should be just beyond the end of the buffer.
 * 3. The attacker must insert machine language instructions in the buffer. 
 * This may occur before, after, or even around the return address pointer. 
 * The machine language could be already compiled code in the program.
 * 4. The attacker must overwrite the return address. The old value, directing 
 * the flow of the program after the function is returned, must be changed 
 * from the calling function to the provided machine language in step 3.

 *************************************/
void stackSmashingExploit()
{
   stackSmashingVulnerability(/* parameters with malicious data */);
}

// Integer Overflow, assigned to:
// Devan
//

/*************************************
 * 1. There must be a security check represented by an expression.
 * 2. The expression must have the potential for overflow.
 * 3. At least one of the numbers used to compute the sentinel must be 
 * reachable through external input. This sentinel is a variable used to make 
 * the security decision from the first requirement
 ****************************************/
void integerOverflowVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * INTEGER WORKING 
 * Call integerOverflowVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void integerOverflowWorking()
{
   integerOverflowVulnerability(/* parameters with non-malicious data */);
}

/**************************************
 * 1. Provide input, either a buffer size or a single value, that is directly or 
 * indirectly used in the vulnerable expression.
 * 2. The input must exceed the valid bounds of the data-type, resulting in an 
 * overflow or underflow condition
 *************************************/
void integerOverflowExploit()
{
   integerOverflowVulnerability(/* parameters with malicious data */);
}

// ANSI Unicode, assigned to:
// Devan
//

/*************************************
 * 1. There must be a buffer where the basetype is greater than one.
 * 2. Validation of the buffer must check the size of the buffer rather than the 
 * number of elements in the buffer.
 ****************************************/
void ansiUnicodeVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * ANSI WORKING 
 * Call ansiUnicodeWorking() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiUnicodeWorking()
{
   ansiUnicodeVulnerability(/* parameters with non-malicious data */);
}

/**************************************
 * 1. The attacker must provide more than half as much data into the 
 * outwardly facing buffer as it is designed to hold.
 * 2. From here, a variety of injection attacks are possible. The most likely 
 * candidates are stack smashing or heap smashing. In the above example, 
 * the third parameter of the copyUnicodeText() function is the number 
 * of elements in the string (256 elements), not the size of the string (512 
 * bytes). The end result is a buffer overrun of 256 bytes.
 *************************************/
void ansiUnicodeExploit()
{
   ansiUnicodeVulnerability(/* parameters with malicious data */);
}

// ARC Injection, assigned to:
// Shaun
//

/*************************************
 * 1. There must be a function pointer used in the code.
 * 2. Through some vulnerability, there must be a way for user input to 
 * overwrite the function pointer. This typically happens through a stack 
 * buffer vulnerability.
 * 3. After the memory is overwritten, the function pointer must be 
 * dereferenced.
 ****************************************/
string pointerFunctionSafe()
{
    return "Safe! :-)";
}

void arcInjectionVulnerability(long buffer[4] /*This fulfills requiermetn 2.*/)
{
    string (*pointerFunction)() = pointerFunctionSafe;                      //This fulfills requierment 1.
        
    if (buffer[0] != '123') pointerFunction = (string(*) ())(buffer);       //This fulfills requierment 3.
    cout << pointerFunction() << endl;
    cout << "This Memory address: " << pointerFunction << endl;
    cout << "Safe Memory address: " << pointerFunctionSafe << endl;    
}

/**************************************
 * ARC WORKING 
 * Call arcInjectionVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arcInjectionWorking()
{
    long input[4];
    
    input[0] = '123';
    cout << "For our working arcInjection function we have an input of: " << input[0] << endl;

    arcInjectionVulnerability(input);
    
}

/**************************************
 * 1. The attacker must exploit a vulnerability allowing unintended access to 
 * the function pointer.
 * 2. The attacker must have the address to another function which is to be 
 * used to replace the existing function pointer.
 *************************************/
void arcInjectionExploit()
{
    long input[4];
    
    input[0] = 0x7113A7;
    cout << "For our exploited arcInjection function we have an input of: 0x7113A7" << endl;
    cout << "\tPres Enter to continue this will cause the program to crash due" << endl;
    cout << "\tThis crash is due to arcInjectionVulnerability being able directly overwrite the function pointer" << endl;
    int wait = 0;
    while (wait == 0) {
        cin.ignore();
        wait = 1;
    }

    arcInjectionVulnerability(input);

}

// V-Table Spraying, assigned to:
// Steve
//

/*************************************
 * 1. The vulnerable class must be polymorphic.
 * 2. The class must have a buffer as a member variable.
 * 3. Through some vulnerability, there must be a way for user input to 
 * overwrite parts of the V-Table.
 * 4. After a virtual function pointer is overwritten, the virtual function must 
 * be called.
 ****************************************/
void vTableSprayingVulnerability(/* feel free to add parameters */)
{
}

/**************************************
 * V-TABLE WORKING 
 * Call vTableSprayingVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void vTableSprayingWorking()
{
   vTableSprayingVulnerability(/* parameters with non-malicious data */);
}

/**************************************
 * 1. Through some vulnerability, the V-Table pointer or a function pointer 
 * within the V-Table must be overwritten.
 * 2. The attacker must have the address to another V-Table pointer or a 
 * function pointer.
 *************************************/
void vTableSprayingExploit()
{
   vTableSprayingVulnerability(/* parameters with malicious data */);
}

// Heap Spraying, assigned to:
// Ivanro
//

/*************************************
 * 1. There must be two adjacent heap buffers.
 * 2. The first buffer must be reachable through external input.
 * 3. The mechanism to fill the buffer from the external input must not 
 * correctly check for the buffer size.
 * 4. The second buffer must be released before the first.
 * 5. The first buffer must be overrun (extend beyond the intended limits of 
 * the array).
 ****************************************/
string displayCharArray (const char *p)
{
  string output;
  for (int i = 0; i < 5; i++)
    output += string (" ") + (p[i] >= ' ' && p[i] <= 'z' ? p[i] : '.');
  return output;
}

void heapSprayingVulnerability (string input)
{
  char *buffer1 = new char[4];
  char *buffer2 = new char[4];

  assert (buffer1 < buffer2);
  cout << "Insert into Buffer #1:" << input << endl;
  strcpy (buffer1, input.c_str ());
  cout << "Buffer 1 Before Delete: " << displayCharArray ((char *) buffer1) << endl;
  cout << "Buffer 2 Before Delete: " << displayCharArray ((char *) buffer2) << endl;

  delete[]buffer2;
  delete[]buffer1;

    cout << "Buffer 1 After Delete: " << displayCharArray ((char *) buffer1) << endl;
  cout << "Buffer 2 After Delete: " << displayCharArray ((char *) buffer2) << endl;
}

/**************************************
 * HEAP WORKING
 * Call heapSprayingVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void heapSprayingWorking()
{
  cout << "************ Heap Spray Working ************\n";
  string safeInput = "safe";
  heapSprayingVulnerability (safeInput);
  cout << endl;
  }

/**************************************
 * 1. The attacker must provide more data into the outwardly facing heap
 * buffer than the buffer is designed to hold.
 * 2. The attacker must know the layout of the Memory Control Block (MCB)
 * (essentially a linked list) residing just after the buffer.
 * 3. The attacker must provide a new MCB containing both the location of
 * the memory overwrite and the new data to be overwritten.
 *************************************/
void heapSprayingExploit()
{
  cout << "************ Heap Spray Exploit ************\n";
  string badInput = "exploitVulnerability";
  heapSprayingVulnerability (badInput);
  }


int main() {
   heapSprayingWorking ();
  heapSprayingExploit ();

  return 0;
}
